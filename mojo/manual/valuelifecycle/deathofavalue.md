# 值的销毁
一旦一个值/对象不再被使用，Mojo会销毁它。Mojo不会等到代码块的结束，甚至不会等到表达式的结束，就会销毁一个未使用的值。它使用“尽快销毁”（ASAP）的销毁策略，在每个子表达式之后运行。即使在类似`a+b+c+d`这样的表达式中，一旦中间值不再需要，Mojo也会立即销毁它们。

Mojo使用静态编译器分析来找到值最后使用的点。然后，Mojo立即结束值的生命周期，并调用`__del__()`析构函数来执行类型所需的任何清理操作。

例如，注意每个`MyPet`实例的`__del__()`析构函数的调用：

```mojo
@value
struct MyPet:
    var name: String
    var age: Int

    fn __del__(owned self):
        print("Destruct", self.name)

fn pets():
    var a = MyPet("Loki", 4)
    var b = MyPet("Sylvie", 2)
    print(a.name)
    # "Loki"的时候a.__del__()在这里运行

    a = MyPet("Charlie", 8)
    # "Charlie"从未使用，a.__del__()立即运行

    print(b.name)
    # b.__del__()在这里运行

pets()
```

    Loki
    Destruct Loki
    Destruct Charlie
    Sylvie
    Destruct Sylvie

注意，每次值的初始化都与析构函数的调用相匹配，而且`a`实际上会被多次销毁——每次接收新值时都会销毁一次。

还要注意，此`__del__()`实现实际上没有做任何事情。大多数结构体不需要自定义析构函数，如果你没有定义一个，Mojo会自动添加一个空操作的析构函数。

## 默认的销毁行为

你可能想知道Mojo如何在没有自定义析构函数的情况下销毁类型，或者为什么空操作的析构函数有用。如果一个类型只是一组字段的集合，就像`MyPet`的例子一样，Mojo只需要销毁这些字段：`MyPet`不会动态分配内存，也不会使用任何长期存在的资源（比如文件句柄）。当销毁一个`MyPet`值时，不需要执行任何特殊的操作。

从单个字段来看，`MyPet`包含一个`Int`和一个`String`。`Int`是Mojo称为_trivial type_的类型。它是一个静态大小的一组位。Mojo精确地知道它有多大，所以这些位可以被重用来存储其他内容。

`String`值稍微复杂一些。Mojo的字符串是可变的。`String`对象有一个内部缓冲区，即`List`字段，它存储组成字符串的字符。`List`将其内容存储在堆上动态分配的内存中，所以字符串可以增长或缩小。字符串本身没有任何特殊的析构逻辑，但是当Mojo销毁一个字符串时，它会调用`List`字段的析构函数，该析构函数会释放内存。

由于`String`和`Int`不需要任何自定义的析构逻辑，它们都有空操作的析构函数：实际上就是什么也不做的`__del__()`方法。这可能看起来毫无意义，但它意味着当一个值的生命周期结束时，Mojo可以调用它的析构函数。这使得编写通用容器和算法更加容易。

## 尽快销毁的好处

与其他语言类似，Mojo遵循对象/值在构造函数（`__init__()`）中获取资源，在析构函数（`__del__()`）中释放资源的原则。但是，与其他语言不同的是，Mojo会尽快销毁未使用的值。这种尽快销毁的策略有以下几个好处：

- **减少内存占用**：如果一个值不再被使用，那么尽快销毁它可以立即释放它占用的内存。这对于处理大量数据的应用程序特别有用。

- **提高性能**：尽快销毁未使用的值可以减少垃圾回收的负担，从而提高程序的性能。垃圾回收是一种非常昂贵的操作，所以减少垃圾回收的次数可以加快程序的执行速度。

- **更可预测的行为**：尽快销毁值可以减少资源泄漏的风险。如果一个值不再被使用，但仍然保持在内存中，它可能会导致资源泄漏，从而消耗系统资源并降低程序的可靠性。通过尽快销毁未使用的值，可以更容易地避免这些问题。

- **更简单的代码**：由于值的生命周期是明确的，所以在编写代码时不需要手动释放资源。这可以减少开发人员的工作量，并减少出错的机会。

总之，Mojo的尽快销毁策略可以提供更高效、更可靠和更简单的编程体验。它可以帮助开发人员避免常见的资源管理问题，并提高程序的性能和可维护性。

## 区域生命周期

除了追踪程序中所有对象的生命周期之外，Mojo还独立地跟踪每个结构字段的生命周期。也就是说，Mojo会跟踪“整个对象”是否完全或部分初始化/销毁，并使用其尽快销毁策略独立地销毁每个字段。

例如，考虑以下更改字段值的代码：

```mojo
@value
struct MyPet:
    var name: String
    var age: Int

fn use_two_strings():
    var pet = MyPet("Po", 8)
    print(pet.name)
    # pet.name.__del__() 在此处运行，因为此实例不再使用；它在下面被替换掉

    pet.name = String("Lola") # 重写 pet.name
    print(pet.name)
    # pet.__del__() 在此处运行
```

在第一次 `print()` 之后，`pet.name` 字段被销毁，因为Mojo知道它将在下面被覆盖。当使用传输操作符时，您也可以看到这种行为：

```mojo
fn consume(owned arg: String):
    pass

fn use(arg: MyPet):
    print(arg.name)

fn consume_and_use():
    var pet = MyPet("Selma", 5)
    consume(pet.name^)
    # pet.name.__moveinit__() 在此处运行，它销毁了 pet.name
    # 现在 pet 只部分初始化

    # use(pet)  # 这会失败，因为 pet.name 未初始化

    pet.name = String("Jasper")  # 现在一切就绪
    use(pet)                     # 这样是可以的
    # pet.__del__() 在此处运行（仅当对象是完整的时）
```

请注意，该代码将 `name` 字段的所有权传递给 `consume()`。在此之后的一段时间内，`name` 字段未初始化。然后，在将其传递给 `use()` 函数之前，重新初始化 `name`。如果在 `name` 被重新初始化之前尝试调用 `use()`，Mojo会拒绝该代码，并报告未初始化字段错误。

此外，如果在 `pet` 生命周期结束之前没有重新初始化 `name`，编译器会发出警告，因为无法销毁部分初始化的对象。

Mojo在这里的策略非常强大且明确：字段可以临时传递，但是“整个对象”必须使用聚合类型的初始化器构造，并使用聚合析构器销毁。这意味着无法仅通过初始化字段来创建对象，同样无法仅销毁字段来销毁对象。

## 析构和移动期间的字段生命周期

消费移动构造函数和析构函数在字段生命周期方面面临一个有趣的情况，因为与其他生命周期方法不同，它们都需要以 `owned` 参数的形式接收它们自己类型的实例，该实例即将被销毁。当您实现这些方法时，您实际上不需要担心此细节，但它可能有助于更好地理解字段生命周期。

简要回顾一下，移动构造函数和析构函数的方法签名如下：

```mojo
struct TwoStrings:
    fn __moveinit__(inout self, owned existing: Self):
        # 通过消耗 `existing` 的内容初始化新的 `self`
    fn __del__(owned self):
        # 销毁 `self` 中的所有资源
```

这里有两种类型的 "self"：大写的 `Self` 是当前类型名称的别名（用作 `existing` 参数的类型指定符），而小写的 `self` 是当前实例的隐式传递引用的参数名称（在其他语言中也称为 "this"，也是隐式的 `Self` 类型）。

这两个方法都面临一个有趣但晦涩的问题：它们都必须消耗 `existing` 的内容，但在这之后，它们也必须将字段设置为未初始化状态。这是因为 `existing` 是一个 `owned` 参数，它的生命周期在当前方法结束时结束。如果我们不将字段设置为未初始化状态，那么 `existing` 的生命周期将延长到当前实例的整个生命周期，这是不正确的。

为了克服这个问题，Mojo引入了一个特殊的函数 `__moveinit__()`，用于将字段设置为未初始化状态。当使用 `existing` 参数初始化字段后，您可以调用 `__moveinit__()` 函数将字段设置为未初始化状态。这是一个特殊的函数，编译器将在编译时自动插入，以确保字段的正确生命周期。

以下是使用 `__moveinit__()` 的示例：

```mojo
@value
struct MyPet:
    var name: String
    var age: Int

fn moveinit_example(existing: MyPet):
    var pet = MyPet("Po", 8)
    pet = existing  # 使用 `existing` 初始化 `pet`
    existing.__moveinit__()  # 设置 `existing.name` 和 `existing.age` 为未初始化
    # 现在 `existing.name` 和 `existing.age` 为空，但 `pet.name` 和 `pet.age` 是正确初始化的

    # 在这里使用 `pet` 和 `existing`，它们的生命周期将在此函数结束时结束
```

在这个例子中，我们使用 `existing` 参数初始化了新的 `pet` 对象，并在此之后调用了 `__moveinit__()` 函数。这样，`existing` 的生命周期将在函数结束时结束，而 `pet` 的所有字段将正确初始化。

在析构函数中也有相同的问题和解决方案。当调用析构函数时，我们必须将所有字段设置为未初始化状态，以便它们的生命周期随着当前实例的生命周期结束。同样，我们可以使用 `__moveinit__()` 函数来实现这一点：

```mojo
@value
struct MyPet:
    var name: String
    var age: Int

fn del_example(pet: MyPet):
    pet.__del__()  # 销毁 `pet` 的所有字段，并将它们设置为未初始化
    # `pet.name` 和 `pet.age` 现在为空
    # 但是 `pet` 的生命周期也结束了，因此无论其字段是否初始化，都不会有任何问题
```

在这个例子中，我们调用了 `__del__()` 函数来销毁 `pet` 的所有字段，并将它们设置为未初始化状态。这样，无论字段是否初始化，都不会有任何问题，因为 `pet` 的生命周期已经结束。

总而言之，这些特殊的 `__moveinit__()` 和 `__del__()` 函数确保了在消费移动构造函数和析构函数期间正确处理字段的生命周期。您不需要手动调用这些函数，编译器会自动插入它们。但了解它们的作用和原因可能会有所帮助，特别是在处理字段生命周期方面的更高级问题时。